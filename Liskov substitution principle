роектування за контрактом
Принцип заміщення Лісков близько стосується методології проектування за контрактом, і веде до деяких обмежень на те, як контракти можуть взаємодіяти з успадкуванням:

Передумови не можуть бути посилені в підтипі.
Післяумови не можуть бути послаблені в підтипі.
Інваріанти базового типу повинні виконуватись у підтипі.
«Історичне обмеження»: заборона модифікації стану об'єкта методами підтипу, які відсутні в базовому типі.
Функція, що обробляє ієрархію класів з порушеннями принципу Лісков, використовує посилання на базовий клас, але також вимушена мати інформацію про підклас. Така функція також порушує принцип відкритості/закритості оскільки її необхідно змінювати в разі появи нових похідних класів.

У цьому контексті принцип заміщення Лісков можна переформулювати так:

Функції, які використовують посилання на базові класи, повинні мати можливість використовувати об'єкти похідних класів, не знаючи про це.
Андрей Александреску та Герб Саттер в книзі «C++ Coding Standards» описують виконання цього принципу так:

«Підклас не повинен вимагати від коду, що його викликає, більше ніж вимагав базовий клас. І повинен надавати цьому коду не менше ніж надавав базовий клас».
На думку авторів, публічне успадкування можна використовувати тільки коли виконується принцип LSP. Приватне успадкування дозволене тільки для доступу до protected частини та заміщення віртуальних методів. Для всіх інших випадків, успадковування використовувати не бажано.

Приклад
Роберт Мартін зазначає, що до перших ознак порушення принципу підстановки Лісков є наявність функцій, які перевіряють тип отриманого аргументу для визначення своєї поведінки:[3]

void DrawShape(const Shape& s)
{
  if (typeid(s) == typeid(Square))
    DrawSquare(static_cast<Square&>(s));
  else if (typeid(s) == typeid(Circle))
    DrawCircle(static_cast<Circle&>(s));
}
Таке може трапитись коли успадковані класи порушують контракт базового класу. Наприклад, квадрат можна представити як підклас прямокутника, оскільки квадрат це і є прямокутник з рівними сторонами (інший наведений ним приклад коло — вироджений випадок еліпсу)[3].

Однак, оскільки квадрат успадкує від прямокутника обидва атрибута — ширину і висоту, то постане проблема: як гарантувати їхню рівність в методах присвоєння (так званих «сеттерах»)? Просте рішення може мати такий вигляд:

void Square::SetWidth(double w)
{ 
  Rectangle::SetWidth(w);
  Rectangle::SetHeight(w);
}
void Square::SetHeight(double h)
{
  Rectangle::SetHeight(h);
  Rectangle::SetWidth(h);
}
Але такий код порушує принцип підстановки Лісков для тих функцій, які покладаються на збереження переданих значень:

void g(Rectangle& r)
{
  r.SetWidth(5);
  r.SetHeight(4);
  assert(r.GetWidth() * r.GetHeight()) == 20);
}
